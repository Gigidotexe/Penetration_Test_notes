# HTTP Enumeration

Il protocollo HTTP (HyperText Transfer Protocol) è lo standard su cui si basa il web. Durante un penetration test, l’enumerazione HTTP è fondamentale per scoprire:

- Quali tecnologie e framework web sono in uso.
- Quali directory o file nascosti sono accessibili.
- Quali vulnerabilità note affliggono i componenti web.
- La presenza di pagine di login, aree admin o portali di debug.
- Il comportamento del server in risposta a richieste anomale.

Le porte più comuni per servizi web sono `80` (HTTP) e `443` (HTTPS), ma molti siti girano anche su `8080`, `8443`, `8000` e altre porte non standard.

## Identificazione iniziale

La prima fase consiste nel visitare manualmente l’host nel browser o tramite `curl`:

- `curl -I <target>` → mostra gli header HTTP (inclusi server, cookie, redirect)
- `curl -k https://<target>` → ignora errori di certificato SSL

L’header `Server` può rivelare il software in uso (es. `Apache`, `nginx`, `IIS`) e la versione, utile per correlare CVE. Alcuni server restituiscono anche header `X-Powered-By` (es. `PHP/5.6.40`, `ASP.NET`).

## WhatWeb e Wappalyzer

Strumenti per il fingerprinting del sito:

- `whatweb <URL>` → identifica CMS, tecnologie, versioni.
- `wappalyzer` (estensione browser) → mostra librerie JS, linguaggi backend, framework, analytics, ecc.

Utile per sapere se stai affrontando un WordPress, Joomla, Laravel, Django, Tomcat, ecc.

## Directory Brute Force

Tecnica fondamentale per trovare directory nascoste, pannelli admin, file di backup.

### Gobuster

- `gobuster dir -u http://<target> -w /usr/share/wordlists/dirb/common.txt -t 50`

Parametri:

- `-u`: URL
- `-w`: wordlist
- `-t`: numero di thread (default 10)

Supporta anche fuzzing di estensioni:

- `-x php,txt,bak`

### Dirb

- `dirb http://<target> /usr/share/wordlists/dirb/common.txt`

Simile a Gobuster, meno veloce ma con output più leggibile.

### Ffuf

- `ffuf -u http://<target>/FUZZ -w <wordlist>`

Molto flessibile per fuzzing avanzato (form, parametri, host, ecc.)

## Robots.txt

Accessibile via `http://<target>/robots.txt`, è spesso usato per indicare ai crawler cosa non indicizzare. Gli attaccanti lo consultano per trovare directory "riservate".

Esempio:

User-agent: *
Disallow: /admin/
Disallow: /backup/

Queste path possono essere testate direttamente.

## CMS e pannelli noti

Identificato il CMS (es. WordPress), si possono usare tool specifici:

- `wpscan --url <URL>` → vulnerabilità note, utenti, plugin
- `droopescan scan drupal -u <URL>`
- `joomscan` per Joomla

Verifica anche la presenza di `/admin`, `/login`, `/phpmyadmin`, `/wp-login.php`, ecc.

## Webshell e file upload

Se trovi moduli di **upload**, verifica:

- Se è possibile caricare `.php`, `.jsp`, `.asp`, `.exe`.
- Se il file è accessibile pubblicamente dopo l’upload.
- Se vengono validati nome, estensione, MIME type.

Upload vulnerabili consentono **Remote Code Execution (RCE)** o reverse shell.

## Tecniche manuali

### View Source

Cerca:

- Commenti HTML (`<!-- -->`)
- JS con URL o API (`fetch("/admin/api")`)
- Path nascosti (`action="/hidden"`)
- Chiavi, token o credenziali hardcoded

### Ispezione con DevTools

Verifica richieste AJAX, parametri, header particolari, cookie non sicuri (`HttpOnly`, `Secure`, `SameSite`).

## Nikto

Scanner semplice ma utile:

- `nikto -h <URL>`

Cerca:

- File pericolosi
- Directory comuni
- Configurazioni deprecate
- Problemi SSL

## Nmap e HTTP NSE

- `nmap --script http-title <IP>` → titolo della pagina
- `nmap --script http-enum <IP>` → directory comuni
- `nmap --script http-methods <IP>` → metodi HTTP permessi
- `nmap --script http-headers <IP>` → header server

## Considerazioni finali

L’enumerazione HTTP può rivelare enormi quantità di informazioni. Anche un semplice commento HTML può contenere:

- Path a script interni
- Nomi utente o email
- API non documentate

Verifica sempre:

- Se le directory scoperte sono accessibili.
- Se i moduli di login possono essere brute-forzati.
- Se i file `.bak`, `.old`, `.zip` possono essere scaricati e contengono codice sorgente.

Le applicazioni web sono uno degli entry point più sfruttati nei penetration test reali. Lavorare bene su questa fase aumenta le probabilità di accesso remoto o escalazione.

# Salviamo la sezione HTTP Enumeration
with open("/mnt/data/HTTP_Enumeration_clean_codeblock.txt", "w") as f:
    f.write(http_enumeration)

"/mnt/data/HTTP_Enumeration_clean_codeblock.txt"  
